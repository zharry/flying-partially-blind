import sys
sys.path.append("..")

import numpy as np
from collections import deque
from heapq import heappush, heappop
from typing import List, Tuple

import config
from drone.state import DroneState
from drone.action import DroneAction

class DroneMDP:
    def __init__(self):
        self.obstacle_clearance = config.ASTAR_OBSTACLE_CLEARANCE
        self.shortest_path = self._astar_compute_shortest_path()
        self.shortest_path_distance = self._astar_compute_path_distance()
        self._bfs_cache = {}  # Cache for BFS results: {position_tuple: (bfs_distance, distance_along_path)}
    
    # A* Algorithm was generated by Cursor/Claude 4.5 Sonnet
    def _astar_compute_shortest_path(self) -> List[np.ndarray]:
        """
        Compute the shortest path from starting position to goal using A*.
        Ignores wind and maintains clearance from obstacles.
        Runs once and the path is saved as self.shortest_path.
        
        Returns:
            List of positions representing the shortest path
        """

        start = tuple(config.STARTING_POSITION[0])
        goal = tuple(config.GOAL_POSITION)
        
        # Priority queue: (f_score, g_score, position)
        open_set = []
        heappush(open_set, (0, 0, start))
        
        # Track visited nodes and their costs
        came_from = {}
        g_score = {start: 0}
        
        def heuristic(pos: Tuple[int, int]) -> float:
            """Euclidean distance heuristic"""
            return np.linalg.norm(np.array(pos) - np.array(goal))
        
        def is_valid_position(pos: Tuple[int, int]) -> bool:
            """Check if position is valid (in bounds and away from obstacles)"""
            x, y = pos
            
            # Check bounds
            if x < 0 or x >= config.GRID_SIZE or y < 0 or y >= config.GRID_SIZE:
                return False
            
            # Check clearance from obstacles
            pos_array = np.array([x, y], dtype=float)
            for obstacle in config.OBSTACLES:
                distance = np.linalg.norm(pos_array - obstacle)
                if distance < self.obstacle_clearance:
                    return False
            
            return True
        
        def get_neighbors(pos: Tuple[int, int]) -> List[Tuple[int, int]]:
            """Get valid neighboring positions (8-directional movement)"""
            x, y = pos
            neighbors = []
            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    if dx == 0 and dy == 0:
                        continue
                    new_pos = (x + dx, y + dy)
                    if is_valid_position(new_pos):
                        neighbors.append(new_pos)
            return neighbors
        
        # A* main loop
        while open_set:
            _, current_g, current = heappop(open_set)
            
            # Check if we reached the goal
            if np.linalg.norm(np.array(current) - np.array(goal)) <= config.GOAL_THRESHOLD:
                # Reconstruct path
                path = []
                pos = current
                while pos in came_from:
                    path.append(np.array(pos, dtype=float))
                    pos = came_from[pos]
                path.append(np.array(start, dtype=float))
                path.reverse()
                return path
            
            # Skip if we've already found a better path to this position
            if current in g_score and current_g > g_score[current]:
                continue
            
            # Explore neighbors
            for neighbor in get_neighbors(current):
                # Calculate tentative g_score (cost from start to neighbor)
                # Use Euclidean distance for edge cost
                edge_cost = np.linalg.norm(np.array(neighbor) - np.array(current))
                tentative_g = current_g + edge_cost
                
                # If this path to neighbor is better than any previous one
                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score = tentative_g + heuristic(neighbor)
                    heappush(open_set, (f_score, tentative_g, neighbor))
        
        # If no path found, return direct path (fallback)
        print("Warning: No valid A* path found, using direct path, check clearance requirements")
        return [np.array(start, dtype=float), np.array(goal, dtype=float)]
    
    def _astar_compute_path_distance(self) -> float:
        """
        Compute the total distance of the shortest path.
        Runs once and the distance is saved as self.shortest_path_distance.
        
        Returns:
            Total distance along the path
        """
        if len(self.shortest_path) < 2:
            return 0.0
        
        total_distance = 0.0
        for i in range(len(self.shortest_path) - 1):
            total_distance += np.linalg.norm(
                self.shortest_path[i + 1] - self.shortest_path[i]
            )
        return total_distance
    
    def _astar_path_get_closest_point_on_path_with_bfs(self, position: np.ndarray) -> Tuple[float, float]:
        """
        Use BFS to find the closest reachable point on the A* path.
        If multiple points have the same BFS distance, choose the one furthest along the path.
        Results are cached to avoid redundant BFS computations.
        
        Args:
            position: Current position
            
        Returns:
            Tuple of (bfs_distance, distance_along_path)
            - bfs_distance: BFS distance to reach the closest point on the path
            - distance_along_path: Cumulative distance along the A* path to that point
        """
        if len(self.shortest_path) < 2:
            return 0.0, 0.0
        
        # Convert current position to grid coordinates
        start_pos = tuple(np.round(position).astype(int))
        
        # Validate start position is in bounds
        if start_pos[0] < 0 or start_pos[0] >= config.GRID_SIZE or \
           start_pos[1] < 0 or start_pos[1] >= config.GRID_SIZE:
            # If out of bounds, clamp to bounds and continue
            start_pos = (
                max(0, min(config.GRID_SIZE - 1, start_pos[0])),
                max(0, min(config.GRID_SIZE - 1, start_pos[1]))
            )
        
        # Check cache first
        if start_pos in self._bfs_cache:
            return self._bfs_cache[start_pos]
        
        # Helper function to compute distance along the A* path for a given segment and projection
        def get_distance_along_path(segment_idx: int, projection_point: np.ndarray) -> float:
            distance_along_path = 0.0
            for i in range(segment_idx):
                distance_along_path += np.linalg.norm(
                    self.shortest_path[i + 1] - self.shortest_path[i]
                )
            distance_along_path += np.linalg.norm(
                projection_point - self.shortest_path[segment_idx]
            )
            return distance_along_path
        
        # Helper function to find closest point on path from a grid position
        def get_closest_path_info(grid_pos: Tuple[int, int]) -> Tuple[float, int, np.ndarray]:
            """Returns (euclidean_distance_to_path, best_segment, projection_point)"""
            pos_array = np.array(grid_pos, dtype=float)
            min_dist = float('inf')
            best_segment = 0
            best_projection = self.shortest_path[0]
            
            for i in range(len(self.shortest_path) - 1):
                projection = self.closest_point_on_segment(
                    self.shortest_path[i],
                    self.shortest_path[i + 1],
                    pos_array
                )
                dist = np.linalg.norm(pos_array - projection)
                if dist < min_dist:
                    min_dist = dist
                    best_segment = i
                    best_projection = projection
            
            return min_dist, best_segment, best_projection
        
        # Check if we're already on or very close to the path
        dist_to_path, best_seg, best_proj = get_closest_path_info(start_pos)
        if dist_to_path <= 0.5:  # Already on the path
            distance_along = get_distance_along_path(best_seg, best_proj)
            result = (dist_to_path, distance_along)
            self._bfs_cache[start_pos] = result
            return result
        
        # Helper function to check if a position is valid (in bounds and not blocked by obstacles)
        def is_valid_position(pos: Tuple[int, int]) -> bool:
            x, y = pos
            if x < 0 or x >= config.GRID_SIZE or y < 0 or y >= config.GRID_SIZE:
                return False
            
            # Check if position is blocked by an obstacle
            pos_array = np.array([x, y], dtype=float)
            for obstacle in config.OBSTACLES:
                if np.linalg.norm(pos_array - obstacle) <= config.OBSTACLE_THRESHOLD:
                    return False
            return True
        
        # BFS to find closest reachable point on the path
        queue = deque([(start_pos, 0)])  # (position, bfs_distance)
        visited = {start_pos}
        
        # Track best result: (bfs_distance, distance_along_path, grid_pos)
        best_bfs_dist = float('inf')
        best_path_distance = -1.0  # Will track furthest along path for ties
        best_position = start_pos
        
        while queue:
            current_pos, bfs_dist = queue.popleft()
            
            # If we've exceeded the best BFS distance found, stop exploring this branch
            if bfs_dist > best_bfs_dist:
                continue
            
            # Check how close this position is to the A* path
            euclidean_dist, segment, projection = get_closest_path_info(current_pos)
            
            # If this position is on or very close to the path
            if euclidean_dist <= 0.5:
                path_dist = get_distance_along_path(segment, projection)
                
                # Update best if this is closer, or same distance but further along the path
                if bfs_dist < best_bfs_dist or (bfs_dist == best_bfs_dist and path_dist > best_path_distance):
                    best_bfs_dist = bfs_dist
                    best_path_distance = path_dist
                    best_position = current_pos
                
                # Continue searching for other points at the same BFS distance
                # that might be further along the path
            
            # Explore neighbors (8-directional movement)
            cx, cy = current_pos
            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    if dx == 0 and dy == 0:
                        continue
                    
                    neighbor = (cx + dx, cy + dy)
                    if neighbor not in visited and is_valid_position(neighbor):
                        visited.add(neighbor)
                        # All moves count as 1 step in BFS (not weighted by diagonal)
                        queue.append((neighbor, bfs_dist + 1))
        
        # Return the best result found
        if best_bfs_dist == float('inf'):
            # Fallback: use direct Euclidean distance if no path found
            dist_to_path, best_seg, best_proj = get_closest_path_info(start_pos)
            distance_along = get_distance_along_path(best_seg, best_proj)
            result = (dist_to_path, distance_along)
        else:
            result = (float(best_bfs_dist), best_path_distance)
        
        # Cache the result before returning
        self._bfs_cache[start_pos] = result
        return result

    def transition(self, next_tick: int, state: DroneState, action: DroneAction) -> DroneState:
        if next_tick >= config.MAXIMUM_TIME_STEPS:
            raise ValueError(f"Tick {next_tick} exceeds maximum time steps {config.MAXIMUM_TIME_STEPS}")

        # Create a copy of the state to modify
        next_state = state.copy()
        
        # Update velocity
        new_velocity = state.velocity + action.acceleration + state.wind
        next_state.set_velocity(
            self.clip_vector(new_velocity, config.VELOCITY_MIN, config.VELOCITY_MAX)
        )
        
        # Update position
        previous_position = state.position
        new_position = self.clip_vector(
            state.position + next_state.velocity, 
            0, 
            config.GRID_SIZE - 1
        )
        
        # Check for path intersection with obstacles (on the actual clipped path)
        collision_position = self.check_path_collision(previous_position, new_position)
        if collision_position is not None:
            next_state.set_position(collision_position)
        else:
            next_state.set_position(new_position)
        
        # Update battery
        new_battery = state.battery - config.BATTERY_DRAIN_RATE
        next_state.set_battery(
            self.clip_int(new_battery, config.BATTERY_MIN, config.BATTERY_MAX)
        )
        
        # Update wind
        next_state.set_wind(
            self.clip_vector(
            config.WIND[next_tick],
            config.WIND_MIN,
            config.WIND_MAX)
        )
        
        return next_state
    
    def check_path_collision(self, start_pos: np.ndarray, end_pos: np.ndarray) -> np.ndarray:
        # Check each obstacle
        for obstacle in config.OBSTACLES:
            # Calculate the closest point on the line segment to the obstacle
            closest_point = self.closest_point_on_segment(start_pos, end_pos, obstacle)
            distance = np.linalg.norm(closest_point - obstacle)
            
            # If the path passes through the obstacle threshold
            if distance <= config.OBSTACLE_THRESHOLD:
                # Return the obstacle position (drone stops at obstacle)
                return obstacle.copy()
        return None
    
    def closest_point_on_segment(self, start: np.ndarray, end: np.ndarray, point: np.ndarray) -> np.ndarray:
        # Vector from start to end
        segment = end - start
        segment_length_sq = np.dot(segment, segment)
        if segment_length_sq == 0:
            return start
        
        # Project point onto the line, clamped to the segment
        t = np.clip(np.dot(point - start, segment) / segment_length_sq, 0, 1)
        
        # Calculate the closest point on the segment
        closest = start + t * segment
        return closest
    
    def reward(self, state: DroneState, action: DroneAction, next_state: DroneState) -> float:
        # Check if next state is terminal and why
        if next_state.is_terminal():
            # Goal is reached
            if next_state.is_goal_reached():
                return config.GOAL_REWARD
            
            # Collision with obstacle
            if next_state.is_collision():
                return config.COLLISION_PENALTY
            
            # Out of battery
            if next_state.is_out_of_battery():
                return config.BATTERY_EMPTY_PENALTY
        
        # Out of bounds (means touching the boundary)
        if next_state.position[0] <= 0 or next_state.position[0] >= config.GRID_SIZE - 1 or \
           next_state.position[1] <= 0 or next_state.position[1] >= config.GRID_SIZE - 1:
            return config.OUT_OF_BOUNDS_PENALTY

        # Step penalty
        step_penalty = config.STEP_PENALTY
        
        # Progress reward
        progress_reward = self.calculate_progress_reward(state, next_state)
        
        return step_penalty + progress_reward
    
    def calculate_progress_reward(self, state: DroneState, next_state: DroneState) -> float:
        reward = 0.0

        # A* Path Progress to Goal
        # Get distance from path for next state
        current_bfs_distance, current_distance_along_path = self._astar_path_get_closest_point_on_path_with_bfs(state.position)
        next_bfs_distance, next_distance_along_path = self._astar_path_get_closest_point_on_path_with_bfs(next_state.position)
        current_progress = (current_distance_along_path - current_bfs_distance) / self.shortest_path_distance
        next_progress = (next_distance_along_path - next_bfs_distance) / self.shortest_path_distance
        # Current distance to goal using A* path
        progress_delta = next_progress - current_progress
        reward += config.PROGRESS_REWARD_MULTIPLIER * progress_delta
        # Deviation penalty
        deviation_delta = next_bfs_distance - current_bfs_distance
        if next_bfs_distance > config.ASTAR_MAX_DEVIATION:
            reward += config.ASTAR_DEVIATION_PENALTY * deviation_delta
    
        # Euclidean Distance to goal
        # distance_to_goal = np.linalg.norm(next_state.position - config.GOAL_POSITION)
        # reward += config.PROGRESS_REWARD_MULTIPLIER / (
        #     config.PROGRESS_REWARD_EPSILON + distance_to_goal
        # )

        # Euclidean Progress to Goal
        # old_distance = np.linalg.norm(state.position - config.GOAL_POSITION)
        # new_distance = np.linalg.norm(next_state.position - config.GOAL_POSITION)
        # reward = config.PROGRESS_REWARD_MULTIPLIER * (old_distance - new_distance)
        # return reward
    
    @staticmethod
    def clip_int(value: int, min_value: int, max_value: int) -> int:
        return max(min(value, max_value), min_value)

    @staticmethod
    def clip_vector(vector: np.ndarray, min_value: int, max_value: int) -> np.ndarray:
        return np.clip(vector, min_value, max_value)

